grammar ParserT;
import LexerT;
program : BEGIN MAIN BRACE_OPEN codigo* BRACE_CLOSE END;
codigo: (declaracion | escritura | lectura | si | mientras | hacer | calculo | funcionmatematica);
escritura: PRINT PAR_OPEN (NAME_VAR | WORDS)+ PAR_CLOSE SEMICOLON;
lectura: READ PAR_OPEN WORDS COMMA NAME_VAR PAR_CLOSE SEMICOLON;
si: IF PAR_OPEN condicion PAR_CLOSE BRACE_OPEN codigo+ BRACE_CLOSE(ELSE BRACE_OPEN codigo+ BRACE_CLOSE)?;
mientras: WHILE PAR_OPEN condicion PAR_CLOSE BRACE_OPEN codigo+ BRACE_CLOSE;
hacer: DO BRACE_OPEN codigo+ BRACE_CLOSE WHILE PAR_OPEN condicion PAR_CLOSE;
declaracion: (INT | FLOAT | BOOLEAN) NAME_VAR ASSIGN (NUMBER | NAME_VAR | VAL_BOOLEAN) SEMICOLON?;
condicion: (NUMBER | NAME_VAR) (GREATER | LESSER | GREATER_OR_EQUAL | LESSER_OR_EQUAL | EQUAL | NOT_EQUAL) (NUMBER | NAME_VAR);
calculo: suma | resta | multiplicacion | division;
suma: NAME_VAR ASSIGN (NUMBER | NAME_VAR) PLUS (NUMBER | NAME_VAR) SEMICOLON;
resta: NAME_VAR ASSIGN (NUMBER | NAME_VAR) MINUS (NUMBER | NAME_VAR) SEMICOLON;
multiplicacion: NAME_VAR ASSIGN (NUMBER | NAME_VAR) MULT (NUMBER | NAME_VAR) SEMICOLON;
division: NAME_VAR ASSIGN (NUMBER | NAME_VAR) DIV (NUMBER | NAME_VAR) SEMICOLON;
funcionmatematica: raiz | seno | coseno;
raiz: NAME_VAR ASSIGN SQRT PAR_OPEN (NUMBER | NAME_VAR) PAR_CLOSE SEMICOLON;
seno: NAME_VAR ASSIGN SIN PAR_OPEN (NUMBER | NAME_VAR) PAR_CLOSE SEMICOLON;
coseno: NAME_VAR ASSIGN COS PAR_OPEN (NUMBER | NAME_VAR) PAR_CLOSE SEMICOLON;
